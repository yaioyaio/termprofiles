import os, uuid, plistlib, shutil, re, subprocess, tempfile, sys
from typing import Iterable
from .util import slugify, atomic_write_json

ITERM_DP_DIR = os.path.expanduser("~/Library/Application Support/iTerm2/DynamicProfiles")
ZROOT        = os.path.expanduser("~/.zsh-profiles")
ITERM_PREFS  = os.path.expanduser("~/Library/Preferences/com.googlecode.iterm2.plist")

DEFAULT_SETOPTS = [
    "NO_SHARE_HISTORY",
    "HIST_IGNORE_ALL_DUPS",
    "HIST_REDUCE_BLANKS",
    "EXTENDED_HISTORY",
]

AVAILABLE_SETOPTS: list[tuple[str, str]] = [
    ("NO_SHARE_HISTORY", "Keep history per session (default)"),
    ("SHARE_HISTORY", "Push history entries to other sessions immediately"),
    ("HIST_IGNORE_ALL_DUPS", "Skip duplicate commands entirely"),
    ("HIST_REDUCE_BLANKS", "Collapse repeated spaces for compact history"),
    ("HIST_IGNORE_SPACE", "Do not record commands that start with a space"),
    ("HIST_FIND_NO_DUPS", "Remove older duplicates when searching history"),
    ("INC_APPEND_HISTORY", "Append new commands incrementally"),
    ("EXTENDED_HISTORY", "Include timestamp and duration metadata"),
]

def ensure_dirs():
    os.makedirs(ITERM_DP_DIR, exist_ok=True)
    os.makedirs(ZROOT, exist_ok=True)

def _ensure_project_zsh(slug: str):
    proj_dir = os.path.join(ZROOT, slug)
    os.makedirs(proj_dir, exist_ok=True)
    bin_dir = os.path.join(proj_dir, "bin")
    os.makedirs(bin_dir, exist_ok=True)
    hist = os.path.join(proj_dir, ".zsh_history")
    zrc  = os.path.join(proj_dir, ".zshrc")
    if not os.path.exists(zrc):
        with open(zrc, "w", encoding="utf-8") as f:
            setopts = " ".join(DEFAULT_SETOPTS)
            f.write(f"""# per-project zshrc (auto)
export HISTFILE="{hist}"; export HISTSIZE=50000; export SAVEHIST=50000
setopt {setopts}
[ -d "$ZDOTDIR/bin" ] && export PATH="$ZDOTDIR/bin:$PATH"
[ -f "$HOME/.zshrc.common" ] && source "$HOME/.zshrc.common"
# PROMPT="[%F{{cyan}}{slug}%f] %n@%m %~ %# "  # 부모 테마 그대로 쓰려면 주석 유지
""")
    else:
        with open(zrc, "r", encoding="utf-8") as f:
            content = f.read()
        if "$ZDOTDIR/bin" not in content:
            with open(zrc, "a", encoding="utf-8") as f:
                f.write("\n# Added by termprofiles: expose per-profile wrappers\n[ -d \"$ZDOTDIR/bin\" ] && export PATH=\"$ZDOTDIR/bin:$PATH\"\n")
    return proj_dir, hist, zrc


def _dedupe(cmds: list[str] | None) -> list[str]:
    if not cmds:
        return []
    seen: set[str] = set()
    out: list[str] = []
    for c in cmds:
        if not c:
            continue
        if c in seen:
            continue
        seen.add(c)
        out.append(c)
    return out


def _ensure_cli_isolation(slug: str, commands: list[str]) -> list[str]:
    info: list[str] = []
    commands = _dedupe(commands)
    if not commands:
        return info

    proj_dir = os.path.join(ZROOT, slug)
    bin_dir = os.path.join(proj_dir, "bin")
    os.makedirs(bin_dir, exist_ok=True)
    homes_root = os.path.join(proj_dir, "cli-homes")
    os.makedirs(homes_root, exist_ok=True)

    for name in commands:
        real_path = shutil.which(name)
        if not real_path:
            info.append(f"WARN: '{name}' not found on PATH; wrapper skipped")
            continue
        cli_home = os.path.join(homes_root, name)
        os.makedirs(cli_home, exist_ok=True)
        os.makedirs(os.path.join(cli_home, ".config"), exist_ok=True)
        os.makedirs(os.path.join(cli_home, ".local", "share"), exist_ok=True)
        os.makedirs(os.path.join(cli_home, ".cache"), exist_ok=True)
        script_path = os.path.join(bin_dir, name)
        script = f"""#!/bin/sh
# Auto-generated by TermProfiles; isolates {name}
CLI_HOME="{cli_home}"
REAL_BIN="{real_path}"
mkdir -p "$CLI_HOME" "$CLI_HOME/.config" "$CLI_HOME/.local/share" "$CLI_HOME/.cache"
exec env HOME="$CLI_HOME" XDG_CONFIG_HOME="$CLI_HOME/.config" XDG_DATA_HOME="$CLI_HOME/.local/share" XDG_CACHE_HOME="$CLI_HOME/.cache" "$REAL_BIN" "$@"
"""
        with open(script_path, "w", encoding="utf-8") as f:
            f.write(script)
        os.chmod(script_path, 0o755)
        info.append(f"isolated {name} -> {cli_home}")

    return info

def _norm(s: str) -> str:
    return re.sub(r"\s+", " ", (s or "")).strip().casefold()



def _atomic_write_text(path: str, content: str) -> None:
    d = os.path.dirname(path) or "."
    os.makedirs(d, exist_ok=True)
    with tempfile.NamedTemporaryFile("w", delete=False, dir=d, encoding="utf-8") as tmp:
        tmp.write(content)
        tmp_path = tmp.name
    os.replace(tmp_path, path)


def _read_lines(path: str) -> list[str]:
    try:
        with open(path, "r", encoding="utf-8") as f:
            return f.readlines()
    except FileNotFoundError:
        return []


def _write_lines(path: str, lines: Iterable[str]) -> None:
    _atomic_write_text(path, "".join(lines))


def _setopt_from_line(line: str) -> list[str]:
    body = line.strip()
    if not body.startswith("setopt "):
        return []
    return body[len("setopt "):].split()


def _extract_setopts(zrc_path: str) -> list[str]:
    for line in _read_lines(zrc_path):
        opts = _setopt_from_line(line)
        if opts:
            return opts
    return []


def _normalize_setopts(selected: Iterable[str]) -> list[str]:
    order = [name for name, _ in AVAILABLE_SETOPTS]
    seen: set[str] = set()
    normalized: list[str] = []
    for name in selected:
        if not name or name in seen:
            continue
        seen.add(name)
        normalized.append(name)

    if "SHARE_HISTORY" in seen and "NO_SHARE_HISTORY" in seen:
        normalized = [n for n in normalized if n != "NO_SHARE_HISTORY"]

    ordered = [n for n in order if n in normalized]
    extras = [n for n in normalized if n not in order]
    return ordered + extras


def _update_setopt_line(zrc_path: str, new_opts: list[str]) -> None:
    lines = _read_lines(zrc_path)
    new_line = f"setopt {' '.join(new_opts)}\n" if new_opts else "# setopt cleared by termprofiles\n"
    for idx, line in enumerate(lines):
        if line.strip().startswith("setopt ") or line.strip().startswith("# setopt cleared by termprofiles"):
            lines[idx] = new_line
            break
    else:
        lines.append(new_line)
    _write_lines(zrc_path, lines)


def _resolve_profile_target(dirpath: str | None = None, slug_hint: str | None = None) -> tuple[str, str, str, str]:
    if slug_hint:
        slug = slugify(slug_hint)
    else:
        base = os.path.abspath(os.path.expanduser(dirpath or os.getcwd()))
        slug = slugify(base)
    proj_dir, _, zrc = _ensure_project_zsh(slug)
    profile_name = f"proj-{slug}"
    return slug, profile_name, proj_dir, zrc


def _run_osascript(script: str) -> tuple[bool, str]:
    blocks = []
    for app in ("iTerm2", "iTerm"):
        blocks.append(f'tell application "{app}"\n{script}\nend tell')
    errors: list[str] = []
    for block in blocks:
        try:
            subprocess.run(["osascript", "-e", block], check=True, capture_output=True, text=True)
            return True, ""
        except FileNotFoundError:
            return False, "osascript not available"
        except subprocess.CalledProcessError as e:
            errors.append((e.stderr or e.stdout or "").strip())
    return False, "; ".join(filter(None, errors)) or "Unknown AppleScript error"


def _broadcast_reload(profile_name: str, zrc_path: str) -> str:
    source_cmd = f'source "{zrc_path}"'
    escaped = source_cmd.replace('"', '\\"')
    script = f"  repeat with w in windows\n    repeat with t in tabs of w\n      repeat with s in sessions of t\n        if profile name of s is \"{profile_name}\" then\n          tell s to write text \"{escaped}\"\n        end if\n      end repeat\n    end repeat\n  end repeat"
    ok, err = _run_osascript(script)
    if ok:
        return "Reloaded active sessions."
    return f"Could not auto-reload sessions ({err}); run '{source_cmd}' manually."


def _prompt_line(slug: str, enabled: bool) -> str:
    prompt = f'PROMPT="[%F{{cyan}}{slug}%f] %n@%m %~ %# "'
    suffix = "  # 부모 테마 그대로 쓰려면 주석 유지"
    if enabled:
        return f"{prompt}{suffix}\n"
    return f"# {prompt}{suffix}\n"
def resolve_parent_guid_by_name(name: str) -> str | None:
    """Find parent GUID by NAME (case-insensitive, normalized spaces).
       If exact (normalized) match not found, try unique 'contains' match."""
    target = _norm(name)
    try:
        with open(ITERM_PREFS, "rb") as f:
            p = plistlib.load(f)
        choices = p.get("New Bookmarks", [])
        # exact normalized match
        for b in choices:
            if _norm(b.get("Name", "")) == target:
                guid = b.get("Guid")
                return str(guid) if guid else None
        # unique contains match
        cands = [b for b in choices if target and target in _norm(b.get("Name", ""))]
        if len(cands) == 1:
            guid = cands[0].get("Guid")
            return str(guid) if guid else None
    except Exception:
        pass
    return None

def list_parents():
    """Return [(Name, GUID), ...] from iTerm2 preferences."""
    try:
        with open(ITERM_PREFS, "rb") as f:
            p = plistlib.load(f)
        rows = []
        for b in p.get("New Bookmarks", []):
            rows.append((str(b.get("Name", "")), str(b.get("Guid", ""))))
        return rows
    except Exception as e:
        return [("!error reading prefs", str(e))]



def _apply_setopt_mods(selection: Iterable[str], enable: Iterable[str], disable: Iterable[str]) -> list[str]:
    sel = set(selection)
    for name in enable:
        if name:
            sel.add(name)
    for name in disable:
        if name:
            sel.discard(name)
    return _normalize_setopts(sel)


def configure_setopts(
    dirpath: str | None = None,
    slug_hint: str | None = None,
    enable: Iterable[str] | None = None,
    disable: Iterable[str] | None = None,
    force_interactive: bool = False,
) -> str:
    slug, profile_name, _, zrc = _resolve_profile_target(dirpath, slug_hint)
    current = _extract_setopts(zrc)
    if not current:
        current = DEFAULT_SETOPTS[:]

    enable = [n.strip().upper() for n in (enable or []) if n.strip()]
    disable = [n.strip().upper() for n in (disable or []) if n.strip()]

    selection = _apply_setopt_mods(current, enable, []) if enable else current[:]
    selection = _apply_setopt_mods(selection, [], disable) if disable else selection

    interactive_needed = force_interactive or (not enable and not disable)

    if not interactive_needed:
        new_selected = _apply_setopt_mods(selection, [], [])
    else:
        if not sys.stdin.isatty() or not sys.stdout.isatty():
            return "Interactive setopt unavailable (requires TTY)."
        try:
            import curses

            selection_state = {"values": set(selection)}
            options = [name for name, _ in AVAILABLE_SETOPTS]
            labels = {name: desc for name, desc in AVAILABLE_SETOPTS}

            def _ui(stdscr):
                curses.curs_set(0)
                stdscr.nodelay(False)
                idx = 0

                def render():
                    stdscr.erase()
                    stdscr.addstr(0, 0, "Space=toggle  Enter=save  q=cancel")
                    for row, name in enumerate(options, start=2):
                        marker = "[x]" if name in selection_state["values"] else "[ ]"
                        prefix = "> " if row - 2 == idx else "  "
                        stdscr.addstr(row, 0, f"{prefix}{marker} {name}")
                        desc = labels.get(name)
                        if desc:
                            stdscr.addstr(row, 20, desc)
                stdscr.refresh()

            while True:
                render()
                key = stdscr.getch()
                if key in (curses.KEY_UP, ord('k')):
                    idx = (idx - 1) % len(options)
                elif key in (curses.KEY_DOWN, ord('j')):
                    idx = (idx + 1) % len(options)
                elif key == ord(' '):
                    name = options[idx]
                    if name in selection_state["values"]:
                        selection_state["values"].remove(name)
                    else:
                        selection_state["values"].add(name)
                        if name == "SHARE_HISTORY":
                            selection_state["values"].discard("NO_SHARE_HISTORY")
                    if name == "NO_SHARE_HISTORY" and "SHARE_HISTORY" in selection_state["values"]:
                        selection_state["values"].discard("NO_SHARE_HISTORY")
                elif key in (10, 13, curses.KEY_ENTER):
                    return
                elif key in (27, ord('q')):
                    raise KeyboardInterrupt

            curses.wrapper(_ui)
            new_selected = _normalize_setopts(selection_state["values"])
        except KeyboardInterrupt:
            return "Cancelled."
        except Exception as e:
            return f"Interactive setopt unavailable ({e})."

    new_selected = _apply_setopt_mods(new_selected, [], [])

    if set(new_selected) == set(_normalize_setopts(current)):
        return "No setopt changes."

    _update_setopt_line(zrc, new_selected)
    reload_msg = _broadcast_reload(profile_name, zrc)
    return f"Updated setopt for {profile_name}: {' '.join(new_selected)}\n{reload_msg}"


def configure_prompt(state: str, dirpath: str | None = None, slug_hint: str | None = None) -> str:
    if state not in {"on", "off", "toggle"}:
        raise ValueError("state must be on/off/toggle")
    slug, profile_name, _, zrc = _resolve_profile_target(dirpath, slug_hint)
    lines = _read_lines(zrc)
    prefix = f'PROMPT="[%F{{cyan}}{slug}%f]'
    enabled = None
    for idx, line in enumerate(lines):
        if prefix in line:
            is_commented = line.strip().startswith("#")
            if state == "toggle":
                enabled = is_commented
            else:
                enabled = (state == "on")
            lines[idx] = _prompt_line(slug, enabled)
            break
    else:
        enabled = (state != "off")
        lines.append(_prompt_line(slug, enabled))
    _write_lines(zrc, lines)
    reload_msg = _broadcast_reload(profile_name, zrc)
    status = "enabled" if enabled else "disabled"
    return f"Custom prompt {status} for {profile_name}.\n{reload_msg}"


def open_new_session(dirpath: str | None = None, slug_hint: str | None = None, tab: bool = False) -> str:
    slug, profile_name, _, _ = _resolve_profile_target(dirpath, slug_hint)
    if tab:
        script = (
            f"  if (count of windows) is 0 then\n"
            f"    create window with profile \"{profile_name}\"\n"
            f"  else\n"
            f"    tell current window to create tab with profile \"{profile_name}\"\n"
            f"  end if"
        )
    else:
        script = f'  create window with profile "{profile_name}"'
    ok, err = _run_osascript(script)
    if ok:
        return f"Opened new {'tab' if tab else 'window'} for {profile_name}."
    return f"Could not open new session ({err})."


def add(dirpath: str, parent_guid: str | None = None, isolated_clis: list[str] | None = None) -> str:
    ensure_dirs()
    d = os.path.expanduser(dirpath)
    if not os.path.isdir(d):
        return f"Skip (not a dir): {dirpath}"
    slug = slugify(d)
    name = f"proj-{slug}"
    json_path = os.path.join(ITERM_DP_DIR, f"dp-{slug}.json")
    already_exists = os.path.exists(json_path)
    proj_dir, _, _ = _ensure_project_zsh(slug)
    notes = _ensure_cli_isolation(slug, isolated_clis or [])
    if already_exists:
        if notes:
            return f"Updated: {name} ({'; '.join(notes)})"
        return f"Skip (exists): {name}"

    prof = {
        "Name": name,
        "Guid": str(uuid.uuid4()),
        "Custom Directory": "Yes",
        "Working Directory": d,
        "Custom Command": "Yes",
        "Command": f"/usr/bin/env ZDOTDIR=\"{proj_dir}\" /bin/zsh -l",
        # "Rewritable": True,  # 원하면 주석 해제
    }
    if parent_guid:
        prof["Dynamic Profile Parent GUID"] = parent_guid
    data = {"Profiles": [prof]}
    atomic_write_json(json_path, data)
    if notes:
        return f"Added: {name} ({'; '.join(notes)})"
    return f"Added: {name}"

def remove(target: str, keep_zdotdir: bool = False) -> str:
    slug = slugify(target)
    name = f"proj-{slug}"
    json_path = os.path.join(ITERM_DP_DIR, f"dp-{slug}.json")
    msg = []
    if os.path.exists(json_path):
        os.remove(json_path); msg.append(f"Removed JSON: {json_path}")
    else:
        msg.append(f"No JSON: {json_path}")
    proj_dir = os.path.join(ZROOT, slug)
    if os.path.isdir(proj_dir) and not keep_zdotdir:
        shutil.rmtree(proj_dir); msg.append(f"Removed ZDOTDIR: {proj_dir}")
    else:
        msg.append(f"Keep/No ZDOTDIR: {proj_dir}")
    return " | ".join(msg)

def list_profiles() -> list[tuple[str, str]]:
    out = []
    import json
    for fn in sorted(os.listdir(ITERM_DP_DIR)):
        if not (fn.startswith("dp-") and fn.endswith(".json")):
            continue
        path = os.path.join(ITERM_DP_DIR, fn)
        try:
            d = json.load(open(path, encoding="utf-8"))
            for p in d.get("Profiles", []):
                out.append((p.get("Name", "?"), p.get("Working Directory", "?")))
        except Exception as e:
            out.append((f"! invalid: {fn}", str(e)))
    return out
